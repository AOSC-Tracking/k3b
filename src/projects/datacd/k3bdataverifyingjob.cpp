/* 
 *
 * $Id$
 * Copyright (C) 2003 Sebastian Trueg <trueg@k3b.org>
 *
 * This file is part of the K3b project.
 * Copyright (C) 1998-2003 Sebastian Trueg <trueg@k3b.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * See the file "COPYING" for the exact licensing terms.
 */

#include "k3bdataverifyingjob.h"
#include "k3bdatadoc.h"
#include "k3bfileitem.h"
#include "k3bbootitem.h"
#include "k3bdiritem.h"
#include "k3bisooptions.h"

#include <k3bdevice.h>
#include <k3bdevicehandler.h>
#include <k3bmd5job.h>

#include <kdebug.h>
#include <klocale.h>
#include <kio/global.h>
#include <kio/job.h>
#include <kmessagebox.h>

#include <qcstring.h>
#include <qapplication.h>


class K3bDataVerifyingJob::Private
{
public:
  Private() 
    : running(false),
      canceled(false),
      md5Job(0),
      doc(0),
      device(0),
      currentItem(0) {
  }

  bool running;
  bool canceled;
  bool success;
  K3bMd5Job* md5Job;
  K3bDataDoc* doc;
  K3bCdDevice::CdDevice* device;

  K3bDataItem* currentItem;
  bool originalCalculated;
  QString baseDir;
  KIO::filesize_t alreadyCheckedData;
  QCString originalMd5Sum;
  bool filesDiffer;
  int lastProgress;
};


K3bDataVerifyingJob::K3bDataVerifyingJob( QObject* parent, const char* name )
  : K3bJob( parent, name )
{
  d = new Private();
}


K3bDataVerifyingJob::~K3bDataVerifyingJob()
{
  delete d;
}


bool K3bDataVerifyingJob::active() const
{
  return d->running;
}


void K3bDataVerifyingJob::start()
{
  d->canceled = false;
  d->running = true;

  emit started();

  // we cannot compare files if no rockridge has been created since we do not know the
  // filenames in that case.
  if( !d->doc->isoOptions().createRockRidge() ) {
    emit infoMessage( i18n("Unable to verify the written data if Rockridge is disabled."), ERROR );
    emit infoMessage( i18n("K3b does no know the names of the files generated by mkisofs in this case."), ERROR );
    d->running = false;
    emit finished(false);
    return;
  }

  // TODO: do not compare the files from old sessions
  // TODO: do not use doc->size() but calculate the sum of all filesizes in advance (mainly because of the above)

  // first we need to reload and mount the device
  emit newTask( i18n("Reloading the media") );

  connect( K3bCdDevice::reload( d->device ), SIGNAL(finished(bool)),
	     this, SLOT(slotMediaReloaded(bool)) );
}


void K3bDataVerifyingJob::slotMediaReloaded( bool success )
{
  if( !success )
    KMessageBox::information( qApp->activeWindow(), i18n("Please reload the medium and press 'ok'"),
			      i18n("Unable to close the tray") );

  emit newTask( i18n("Mounting media") );

  connect( KIO::mount( true, 0, d->device->mountDevice(), d->device->mountPoint(), false ), SIGNAL(result(KIO::Job*)),
	   this, SLOT( slotMountFinished(KIO::Job*) ) );
}


void K3bDataVerifyingJob::slotMountFinished( KIO::Job* job )
{
  if( d->canceled ) {
    emit canceled();
    d->running = false;
    emit finished(false);
  }

  if( job->error() ) {
    emit infoMessage( i18n("Mounting failed: %1.").arg(job->errorString()), ERROR );
    d->running = false;
    emit finished(false);
  }
  else {
    emit infoMessage( i18n("Successfully mounted media. Starting verification."), INFO );
    emit newTask( i18n("Verifying written data") );

    // initialize some variables
    d->baseDir = d->device->mountPoint();
    if( d->baseDir[d->baseDir.length()-1] != '/' )
      d->baseDir += "/";
    d->currentItem = d->doc->root();
    d->originalCalculated = false;
    d->alreadyCheckedData = 0;
    d->lastProgress = 0;
    d->filesDiffer = false;

    // initialize the job
    if( !d->md5Job ) {
      d->md5Job = new K3bMd5Job( this );
      connect( d->md5Job, SIGNAL(infoMessage(const QString&, int)), this, SIGNAL(infoMessage(const QString&, int)) );
      connect( d->md5Job, SIGNAL(percent(int)), this, SLOT(slotMd5JobProgress(int)) );
      connect( d->md5Job, SIGNAL(finished(bool)), this, SLOT(slotMd5JobFinished(bool)) );
    }

    compareNextFile();
  }
}


void K3bDataVerifyingJob::compareNextFile()
{
  d->currentItem = d->currentItem->nextSibling();
  
  // we only compare files
  while( d->currentItem && !d->currentItem->isFile() )
    d->currentItem = d->currentItem->nextSibling();
  
  d->originalCalculated = false;
  if( d->currentItem ) {
    d->md5Job->setFile( d->currentItem->localPath() );
    d->md5Job->start();
  }
  else {
    // all files have been compared
    if( d->filesDiffer ) {
      finishVerification( false );
    }
    else {
      emit infoMessage( i18n("All files seem binary equal."), STATUS );
      finishVerification( true );
    }
  }
}


void K3bDataVerifyingJob::cancel()
{
  if( active() ) {
    d->canceled = true;
    if( d->md5Job )
      d->md5Job->cancel();
  }
}


void K3bDataVerifyingJob::setDoc( K3bDataDoc* doc )
{
  d->doc = doc;
  if( d->device == 0 )
    d->device = doc->burner();
}


void K3bDataVerifyingJob::setDevice( K3bCdDevice::CdDevice* dev )
{
  d->device = dev;
}


void K3bDataVerifyingJob::slotMd5JobFinished( bool success )
{
  if( d->canceled ) {
    emit canceled();
    finishVerification(false);
  }

  if( success ) {
    if( d->originalCalculated ) {
      // compare the two md5sums
      if( d->originalMd5Sum != d->md5Job->hexDigest() ) {

	bool fileDiffers = true;

	//
	// there is one case when it's ok that original and written file differ:
	// a boot image with enabled boot info table. In this case mkisofs will
	// modify the source (which is a temporary copy of the original we compare to)
	// 
	if( K3bBootItem* bootItem = dynamic_cast<K3bBootItem*>( d->currentItem ) ) {
	  if( bootItem->bootInfoTable() ) {
	    fileDiffers = false;
	  }
	}

	if( fileDiffers ) {
	  d->filesDiffer = true;
	  emit infoMessage( i18n("%1 differs.").arg( d->doc->isoOptions().createJoliet() ? 
						     d->currentItem->jolietPath() : 
						     d->currentItem->k3bPath() ), ERROR );
	}
      }

      d->alreadyCheckedData += d->currentItem->k3bSize();

      // go on with the next file
      compareNextFile();
    }
    else {
      d->originalCalculated = true;
      d->originalMd5Sum = d->md5Job->hexDigest();
      d->md5Job->setFile( d->baseDir + ( d->doc->isoOptions().createJoliet() ? 
					 d->currentItem->jolietPath() : 
					 d->currentItem->k3bPath() ) );
      d->md5Job->start();
    }
  }
  else {
    // The md5job emitted an error message. So there is no need to do this again
    finishVerification(false);
  }
}


void K3bDataVerifyingJob::slotMd5JobProgress( int p )
{
  double percentCurrentFile = (double)p/2.0;
  if( d->originalCalculated )
    percentCurrentFile += 50.0;

  double doneCurrentFile = (double)d->currentItem->k3bSize()*percentCurrentFile/100.0;
  int newProgress = (int)( 100.0 * ((double)d->alreadyCheckedData + doneCurrentFile) / (double)d->doc->size() );

  if( newProgress > d->lastProgress ) {
    d->lastProgress = newProgress;
    emit percent( newProgress );
  }
}


void K3bDataVerifyingJob::finishVerification( bool success )
{
  d->success = success;

  // we need to unmount
  emit newTask( i18n("Unmounting device") );
  connect( KIO::unmount( d->device->mountPoint(), false ), SIGNAL(result(KIO::Job*)),
	   this, SLOT( slotUnmountFinished(KIO::Job*) ) );
}


void K3bDataVerifyingJob::slotUnmountFinished( KIO::Job* job )
{
  if( job->error() ) {
    emit infoMessage( i18n("Unmounting failed: %1.").arg(job->errorString()), ERROR );
  }
  else {
    emit infoMessage( i18n("Successfully unmounted."), INFO );
  }

  d->running = false;
  emit finished(d->success);
}

#include "k3bdataverifyingjob.moc"
